<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

// ===== ワールド生成 =====
function createWorld(){
  const sizeX=64,sizeZ=64,heightBase=4;
  const boxes=[];
  for(let x=0;x<sizeX;x++){
    for(let z=0;z<sizeZ;z++){
      const hill=Math.floor(2*Math.sin(x*0.3)+2*Math.cos(z*0.25));
      const h=Math.max(1,heightBase+hill);
      for(let y=0;y<h;y++) boxes.push({x,y,z});
    }
  }
  const geo=new THREE.BoxGeometry(1,1,1);
  const mat=new THREE.MeshLambertMaterial({color:0x55aa55});
  const mesh=new THREE.InstancedMesh(geo,mat,boxes.length);
  const m=new THREE.Matrix4();
  boxes.forEach((b,i)=>{ m.makeTranslation(b.x,b.y,b.z); mesh.setMatrixAt(i,m); });
  mesh.instanceMatrix.needsUpdate=true;
  const solid=new Set(boxes.map(b=>`${b.x},${b.y},${b.z}`));
  return {mesh,collider:{solid}};
}

// ===== HTML要素 =====
const homeScreen=document.getElementById('homeScreen');
const gameCanvas=document.getElementById('gameCanvas');
const createRoomBtn=document.getElementById('createRoom');
const joinRoomBtn=document.getElementById('joinRoom');
const roomIdInput=document.getElementById('roomIdInput');
const roomIdDisplay=document.getElementById('roomIdDisplay');
const playerNameInput=document.getElementById('playerNameInput');
let roomId;
let playerName='Player';
playerNameInput.addEventListener('input',e=>playerName=e.target.value||'Player');

// ===== インベントリ =====
let inventory=['Assault Rifle','Pistol','Sniper Rifle'];
let selectedIndex=0;
let selectedWeapon=inventory[selectedIndex];
const slots=document.querySelectorAll('.slot');
function updateInventoryUI(){ slots.forEach((s,i)=>s.classList.toggle('selected',i===selectedIndex)); }
slots.forEach((s,i)=>s.addEventListener('click',()=>{ selectedIndex=i; selectedWeapon=inventory[i]; updateInventoryUI(); }));
window.addEventListener('wheel',e=>{ selectedIndex=(e.deltaY<0)?(selectedIndex-1+inventory.length)%inventory.length:(selectedIndex+1)%inventory.length; selectedWeapon=inventory[selectedIndex]; updateInventoryUI(); });
window.addEventListener('keydown',e=>{ if(e.code==='Digit1') selectedIndex=0; else if(e.code==='Digit2') selectedIndex=1; else if(e.code==='Digit3') selectedIndex=2; else return; selectedWeapon=inventory[selectedIndex]; updateInventoryUI(); });

// ===== ホーム画面操作 =====
function startGame(id,isHost){
  homeScreen.style.display='none';
  gameCanvas.style.display='block';
  roomIdDisplay.textContent='Room: '+id;
  initGame(id,isHost);
}
createRoomBtn.addEventListener('click',()=>{ roomId=Math.random().toString(36).substr(2,6); startGame(roomId,true); });
joinRoomBtn.addEventListener('click',()=>{ roomId=roomIdInput.value.trim(); if(roomId) startGame(roomId,false); });

// ===== ゲーム初期化 =====
function initGame(roomId,isHost){
  const scene=new THREE.Scene();
  scene.background=new THREE.Color(0x87ceeb);
  const camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
  const renderer=new THREE.WebGLRenderer({canvas:gameCanvas});
  renderer.setSize(window.innerWidth,window.innerHeight);

  const hemi=new THREE.HemisphereLight(0xffffff,0x444444,1.0); hemi.position.set(0,200,0); scene.add(hemi);
  const dir=new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(100,200,100); scene.add(dir);

  const world=createWorld(); scene.add(world.mesh);

  // ===== プレイヤークラス =====
  class Player{
    constructor(pos,color){
      this.pos=pos.clone();
      this.vel=new THREE.Vector3();
      this.onGround=false;
      const geo=new THREE.BoxGeometry(1,2,1);
      const mat=new THREE.MeshLambertMaterial({ color: color });
      this.mesh=new THREE.Mesh(geo,mat);
      this.mesh.position.copy(this.pos);
      scene.add(this.mesh);
    }
    updateMesh(){ this.mesh.position.copy(this.pos); }
  }

  // 自分プレイヤー
  const player=new Player(new THREE.Vector3(8,16,8),0xED1C24);

  // 他プレイヤー管理
  const otherPlayers={};

  // 入力
  const keyState={};
  window.addEventListener('keydown',e=>keyState[e.code]=true);
  window.addEventListener('keyup',e=>keyState[e.code]=false);

  let yaw=0,pitch=0,locked=false;
  const euler=new THREE.Euler(0,0,0,'YXZ');

  gameCanvas.addEventListener('click',()=>gameCanvas.requestPointerLock());
  document.addEventListener('pointerlockchange',()=>{ locked=(document.pointerLockElement===gameCanvas); });
  document.addEventListener('mousemove',e=>{
    if(!locked) return;
    const sens=0.0025;
    yaw -= e.movementX*sens;
    pitch -= e.movementY*sens;
    pitch=Math.max(-Math.PI/2+0.01,Math.min(Math.PI/2-0.01,pitch));
  });

  function collide(pos){
    const px=Math.floor(pos.x+0.5),py=Math.floor(pos.y),pz=Math.floor(pos.z+0.5);
    for(let y=py;y<=py+1;y++){ if(world.collider.solid.has(`${px},${y},${pz}`)) return true; }
    return false;
  }

  // ===== WebSocket & WebRTCで簡易マルチプレイ =====
  const socket = new WebSocket('wss://YOUR_SIGNAL_SERVER'); // ←自分で用意するサーバー
  const peers={};
  const localId=Math.random().toString(36).substr(2,6);

  socket.onopen = ()=>{ socket.send(JSON.stringify({type:'join',room:roomId,id:localId})); };
  socket.onmessage = async msg=>{
    const data = JSON.parse(msg.data);
    if(data.type==='offer'){ await handleOffer(data); }
    else if(data.type==='answer'){ await handleAnswer(data); }
    else if(data.type==='ice'){ await handleICE(data); }
    else if(data.type==='join' && data.id!==localId){ await createPeer(data.id,true); }
  };

  async function createPeer(peerId,initiator){
    const pc = new RTCPeerConnection();
    const dc = pc.createDataChannel('game');
    dc.onopen = ()=>console.log('DC open',peerId);
    dc.onmessage = e=>{
      const pos = JSON.parse(e.data);
      if(!otherPlayers[peerId]) otherPlayers[peerId]=new Player(new THREE.Vector3(),0x0000ff);
      otherPlayers[peerId].pos.set(pos.x,pos.y,pos.z);
    };
    pc.onicecandidate = e=>{ if(e.candidate) socket.send(JSON.stringify({type:'ice',candidate:e.candidate,to:peerId})); };
    peers[peerId] = {pc,dc};

    if(initiator){
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.send(JSON.stringify({type:'offer',offer,to:peerId,from:localId}));
    }

    pc.ondatachannel = e=>{
      const ch = e.channel;
      ch.onmessage = msg=>{
        const pos = JSON.parse(msg.data);
        if(!otherPlayers[peerId]) otherPlayers[peerId]=new Player(new THREE.Vector3(),0x0000ff);
        otherPlayers[peerId].pos.set(pos.x,pos.y,pos.z);
      };
      peers[peerId].dc = ch;
    };
  }

  async function handleOffer(data){
    const pc = new RTCPeerConnection();
    peers[data.from] = {pc};
    pc.ondatachannel = e=>{
      const ch = e.channel;
      ch.onmessage = msg=>{
        const pos = JSON.parse(msg.data);
        if(!otherPlayers[data.from]) otherPlayers[data.from]=new Player(new THREE.Vector3(),0x0000ff);
        otherPlayers[data.from].pos.set(pos.x,pos.y,pos.z);
      };
      peers[data.from].dc = ch;
    };
    pc.onicecandidate = e=>{ if(e.candidate) socket.send(JSON.stringify({type:'ice',candidate:e.candidate,to:data.from})); };
    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.send(JSON.stringify({type:'answer',answer,to:data.from,from:localId}));
  }

  async function handleAnswer(data){
    await peers[data.from].pc.setRemoteDescription(new RTCSessionDescription(data.answer));
  }

  async function handleICE(data){
    if(peers[data.from]?.pc) await peers[data.from].pc.addIceCandidate(data.candidate);
  }

  function broadcastPosition(){
    const posData = JSON.stringify({x:player.pos.x,y:player.pos.y,z:player.pos.z});
    Object.values(peers).forEach(p=>{ if(p.dc?.readyState==='open') p.dc.send(posData); });
  }

  // ===== 更新 =====
  function update(dt){
    const moveDir=new THREE.Vector3();
    if(keyState['KeyW']) moveDir.z+=1;
    if(keyState['KeyS']) moveDir.z-=1;
    if(keyState['KeyA']) moveDir.x-=1;
    if(keyState['KeyD']) moveDir.x+=1;
    moveDir.normalize();

    const forward=new THREE.Vector3(0,0,-1).applyEuler(euler);
    const right=new THREE.Vector3(1,0,0).applyEuler(euler);
    forward.y=0; right.y=0; forward.normalize(); right.normalize();
    const speed=keyState['ShiftLeft']?12:6;
    const accel=new THREE.Vector3().addScaledVector(forward,moveDir.z*speed).addScaledVector(right,moveDir.x*speed);

    player.vel.x=THREE.MathUtils.damp(player.vel.x,accel.x,15,dt);
    player.vel.z=THREE.MathUtils.damp(player.vel.z,accel.z,15,dt);

    const g=-24; player.vel.y+=g*dt;
    if(keyState['Space'] && player.onGround){ player.vel.y=10; player.onGround=false; }

    const next=player.pos.clone();
    next.x+=player.vel.x*dt; if(collide(next)){ next.x=Math.round(next.x)+(player.vel.x>0?-0.51:0.51); player.vel.x=0; }
    next.z+=player.vel.z*dt; if(collide(next)){ next.z=Math.round(next.z)+(player.vel.z>0?-0.51:0.51); player.vel.z=0; }
    next.y+=player.vel.y*dt;
    if(collide(next)){
      if(player.vel.y<0){ player.onGround=true; player.vel.y=0; next.y=Math.floor(next.y)+1.0; }
      else if(player.vel.y>0){ player.vel.y=0; next.y=Math.ceil(next.y)-0.01; }
    } else player.onGround=false;

    player.pos.copy(next);
    player.updateMesh();

    camera.position.copy(player.pos).add(new THREE.Vector3(0,1.6,0));
    const lookDir=new THREE.Vector3(0,0,-1).applyEuler(euler);
    camera.lookAt(player.pos.clone().add(new THREE.Vector3(0,1.6,0)).add(lookDir));

    // 他プレイヤー更新
    Object.values(otherPlayers).forEach(p=>p.updateMesh());

    broadcastPosition();
  }

  let lastTime=performance.now();
  function animate(){
    const now=performance.now();
    const dt=(now-lastTime)/1000; lastTime=now;
    update(dt);
    renderer.render(scene,camera);
    requestAnimationFrame(animate);
  }
  animate();
}
</script>
